// Tahim Bhuiya
// ElGamal Implementation in C++

#include <iostream>     // For input/output stream
#include <vector>       // For using dynamic arrays
#include <cmath>        // For mathematical functions like pow(), sqrt()
#include <ctime>        // For seeding random number generator with time
#include <cstdlib>      // For rand(), srand()
#include <string>       // For string handling
#include <tuple>        // For returning multiple values from a function using std::tuple

using namespace std;    // To avoid writing std:: repeatedly (e.g., std::cout -> cout)


// Greatest Common Divisor (GCD) using the Euclidean Algorithm
// Recursively computes the GCD of two integers a and b.
// If b is 0, a is the GCD. Otherwise, recursively call gcd(b, a % b).
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}


// Modular Exponentiation (Square-and-Multiply)
int power(int a, int b, int c) {
    int result = 1;
    a = a % c;
    while (b > 0) {
        if (b % 2 == 1)
            result = (result * a) % c;
        a = (a * a) % c;
        b /= 2;
    }
    return result;
}

// Fermat Primality Test
bool is_prime(int p) {
    if (p < 2 || p % 2 == 0) return false;
    return power(2, p - 1, p) == 1;
}

int generate_prime(int bits) {
    int min_val = 1 << (bits - 1);
    int max_val = (1 << bits) - 1;
    int p;
    do {
        p = min_val + rand() % (max_val - min_val);
    } while (!is_prime(p));
    return p;
}

// Generator for a Prime Field
int find_generator(int p) {
    for (int g = 2; g < p; ++g) {
        if (power(g, (p - 1) / 2, p) != 1 && power(g, (p - 1) / 3, p) != 1)
            return g;
    }
    return -1;
}

// Key Generation
tuple<int, int, int, int> generate_keys(int bits) {
    int q = generate_prime(bits);
    int g = find_generator(q);
    int min_key = 1 << (bits / 2);
    int private_key = min_key + rand() % (q - min_key);
    int public_key = power(g, private_key, q);
    return {q, g, private_key, public_key};
}

// Modular Inverse (Extended Euclidean Algorithm)
int modinv(int a, int m) {
    int m0 = m, t, q;
    int x0 = 0, x1 = 1;
    while (a > 1) {
        q = a / m;
        t = m, m = a % m, a = t;
        t = x0, x0 = x1 - q * x0, x1 = t;
    }
    return x1 < 0 ? x1 + m0 : x1;
}

// Encrypt
vector<pair<int, int>> encrypt(const string &msg, int q, int g, int public_key) {
    int k = 2 + rand() % (q - 2);
    int s = power(public_key, k, q);
    vector<pair<int, int>> ciphertext;
    for (char ch : msg) {
        int p1 = power(g, k, q);
        int p2 = ((int)ch * s) % q;
        ciphertext.emplace_back(p1, p2);
    }
    return ciphertext;
}

// Decrypt
string decrypt(const vector<pair<int, int>> &ciphertext, int q, int private_key) {
    string plaintext;
    int h = power(ciphertext[0].first, private_key, q);
    int inv_h = modinv(h, q);
    for (auto &pair : ciphertext) {
        int ch = (pair.second * inv_h) % q;
        plaintext += static_cast<char>(ch);
    }
    return plaintext;
}

int main() {
    srand(time(0));
    int bits;
    cout << "Enter the key size in bits (preferably 8, 12, 16): ";
    while (!(cin >> bits) || bits <= 0) {
        cout << "Please enter a valid positive integer: ";
        cin.clear();
        cin.ignore(1000, '\n');
    }

    auto [q, g, private_key, public_key] = generate_keys(bits);
    cout << "\nPrime Number (q): " << q;
    cout << "\nPublic Key: " << public_key;
    cout << "\nPrivate Key: " << private_key;

    cin.ignore();
    string plaintext;
    cout << "\nEnter the plaintext: ";
    getline(cin, plaintext);

    auto ciphertext = encrypt(plaintext, q, g, public_key);
    cout << "\nCiphertext: ";
    for (auto &pair : ciphertext) {
        cout << "(" << pair.first << ", " << pair.second << ") ";
    }

    string decrypted = decrypt(ciphertext, q, private_key);
    cout << "\nDecrypted Plaintext: " << decrypted << endl;
    return 0;
}