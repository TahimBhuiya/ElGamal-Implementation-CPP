// Tahim Bhuiya
// ElGamal Implementation in C++ 
#include <iostream>
#include <vector>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <string>
#include <tuple>
using namespace std;

// Greatest Common Divisor
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b);
}

// Modular Exponentiation (Square-and-Multiply)
int power(int a, int b, int c) {
    int result = 1;
    a = a % c;
    while (b > 0) {
        if (b % 2 == 1)
            result = (result * a) % c;
        a = (a * a) % c;
        b /= 2;
    }
    return result;
}

// Fermat Primality Test
bool is_prime(int p) {
    if (p < 2 || p % 2 == 0) return false;
    return power(2, p - 1, p) == 1;
}

int generate_prime(int bits) {
    int min_val = 1 << (bits - 1);
    int max_val = (1 << bits) - 1;
    int p;
    do {
        p = min_val + rand() % (max_val - min_val);
    } while (!is_prime(p));
    return p;
}

// Generator for a Prime Field
int find_generator(int p) {
    for (int g = 2; g < p; ++g) {
        if (power(g, (p - 1) / 2, p) != 1 && power(g, (p - 1) / 3, p) != 1)
            return g;
    }
    return -1;
}

// Key Generation
tuple<int, int, int, int> generate_keys(int bits) {
    int q = generate_prime(bits);
    int g = find_generator(q);
    int min_key = 1 << (bits / 2);
    int private_key = min_key + rand() % (q - min_key);
    int public_key = power(g, private_key, q);
    return {q, g, private_key, public_key};
}

// Modular Inverse (Extended Euclidean Algorithm)
int modinv(int a, int m) {
    int m0 = m, t, q;
    int x0 = 0, x1 = 1;
    while (a > 1) {
        q = a / m;
        t = m, m = a % m, a = t;
        t = x0, x0 = x1 - q * x0, x1 = t;
    }
    return x1 < 0 ? x1 + m0 : x1;
}

// Encrypt
vector<pair<int, int>> encrypt(const string &msg, int q, int g, int public_key) {
    int k = 2 + rand() % (q - 2);
    int s = power(public_key, k, q);
    vector<pair<int, int>> ciphertext;
    for (char ch : msg) {
        int p1 = power(g, k, q);
        int p2 = ((int)ch * s) % q;
        ciphertext.emplace_back(p1, p2);
    }
    return ciphertext;
}

// Decrypt
string decrypt(const vector<pair<int, int>> &ciphertext, int q, int private_key) {
    string plaintext;
    int h = power(ciphertext[0].first, private_key, q);
    int inv_h = modinv(h, q);
    for (auto &pair : ciphertext) {
        int ch = (pair.second * inv_h) % q;
        plaintext += static_cast<char>(ch);
    }
    return plaintext;
}

int main() {
    srand(time(0));
    int bits;
    cout << "Enter the key size in bits (preferably 8, 12, 16): ";
    while (!(cin >> bits) || bits <= 0) {
        cout << "Please enter a valid positive integer: ";
        cin.clear();
        cin.ignore(1000, '\n');
    }

    auto [q, g, private_key, public_key] = generate_keys(bits);
    cout << "\nPrime Number (q): " << q;
    cout << "\nPublic Key: " << public_key;
    cout << "\nPrivate Key: " << private_key;